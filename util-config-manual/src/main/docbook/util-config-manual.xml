<?xml version="1.0" encoding="UTF-8"?>
<book xmlns='http://docbook.org/ns/docbook' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd">

    <info>
        <title>Configuration Framework Manual</title>
        <copyright>
            <year>2011</year>
            <holder>Lin.K NV</holder>
        </copyright>
        <date>2011-03-09</date>
        <releaseinfo>1.0.0</releaseinfo>
        <productname>Util</productname>
        <productnumber>${project.version}</productnumber>

        <authorgroup>
            <author>
                <personname>Maarten Billemont</personname>
                <email>maarten.billemont@lin-k.net</email>
            </author>
        </authorgroup>

        <abstract>
            <para>This document describes the design, operation, usage and extensibility of the configuration framework.</para>
        </abstract>
    </info>


    <chapter>
        <title>Introduction</title>
        <para>
            The purpose of this framework is to provides a clean and type-safe way for you to access arbitrary configuration data.  It is
            highly recommended that you extract any modifiable parameters into configuration properties. This makes it trivial to alter the
            way your application works without the need for going back to the code and recompiling a specific build of it.
        </para>
        <para>
            While the internal operation of the framework is complex, simply using the configuration framework is really easy. Essentially,
            all you need to do is create an interface that describes your configuration properties as annotated methods, activate your
            interface and use that interface when you need to look up values for those properties.
        </para>
    </chapter>

    <chapter>
        <title>Your configuration hierarchy</title>

        <para>
            A configuration is a hierarchical structure of configuration groups and properties.  The structure is defined by means of Java
            interface classes.  Each interface defines a configuration group and the methods in the interface define properties or subgroups
            within that group.  For configuration properties, the method's name is the configuration property's base name and the method's
            return value is the type of the property's value.  Internally, all values are stored as character strings, but when accessed,
            they are converted to the appropriate type by the configuration framework before they are handed over to your application. The
            work of finding, loading, caching and converting values is taken care of by the configuration framework. Defining and accessing
            configuration values is clean, trivial and type-safe.
        </para>
        <para>
            The configuration can be used in two ways.  Either you're writing an application that needs its very own configuration framework
            or you're writing an application that will use another application's configuration framework.
        </para>
        <para>
            Imagine a situation where there is a web application which allows customers to create their own company portal site.  This
            hypothetical web application supports modules of portal blocks that can be externally developed.  The portal application would
            provide external module developers with an API for attaching their modules into the portal.  In this case, the portal web
            application should provide the main configuration implementation and the external module developer would use the configuration
            framework that was set up by the portal application.  The external developer can add their own configuration parameters through
            the configuration framework's extension point.
        </para>

        <section>
            <?dbfo-need height="20cm" ?>
            <title>The main application</title>
            <para>
                When you're writing the main application, you'll want to define your application's configuration properties in an interface
                that extends the <code>RootConfig</code> interface provided by the configuration framework.  The <code>RootConfig</code>
                interface is the root of the configuration hierarchy.  As the main configuration provider, you'll want to extend this
                interface and add your own configuration hierarchy to it by adding configuration groups and properties as methods.
            </para>
            <?dbfo-need height="10cm" ?>
            <para>
                Let's go back to the web portal application example.  To allow a client to customize the portal with their own branding,
                we may want to add a group of branding related configuration properties.  The portal may have support for certain web
                services, which the client may need to customize.  We'll group those together as well.  Finally, we'll provide a group of
                properties that relate to the API used by portal modules. Here's what such a <code>RootConfig</code> interface might look like:
                <programlisting language="java" linenumbering="numbered"><![CDATA[
    public interface PortalConfig extends RootConfig {

        BrandingConfig branding();
        ServicesConfig services();
        ModuleConfig module();
    }
                ]]></programlisting>
            </para>
            <para>
                There we are, we've defined the groups of configuration properties that our portal application needs at the root level.
                Defining groups and properties is always purely declarative.  This keeps your work minimal, clean, transparent and easily
                maintainable.  It's highly recommended that you document the methods adequately with JavaDoc.
            </para>
        </section>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Application extensions</title>

            <para>
                If the application you're writing extends another application and you need to use that other application's configuration
                hierarchy, you can still use the configuration framework to define your own specific configuration hierarchy.  However,
                instead of extending the <code>RootConfig</code> (which has already been done by the main application), you'll be obtaining
                your configuration extension via the existing root config's extension point: <code>RootConfig#app</code>.
            </para>
            <?dbfo-need height="10cm" ?>
            <para>
                Going back to the web portal application example, suppose you're writing a module that allows clients to send out
                notifications of certain events. We may want to add a group of configuration properties that configure how email
                notifications would get sent.  We'll also add a group of properties related to SMS message notifications, and one for
                properties related to styling of our module's user interface. Here's what such a configuration interface might look like:
                <programlisting language="java" linenumbering="numbered"><![CDATA[
    @Group(prefix = "notifications")
    public interface NotificationsModuleConfig extends AppConfig {

        EMailConfig email();
        SMSConfig sms();
        StyleConfig style();
    }
                ]]></programlisting>
            </para>
            <para>
                A few key differences between this configuration group and the one we created for the root config: Unlike
                <code>RootConfig</code> in the example above, this interface extends <code>AppConfig</code>.  That's because this interface
                defines an application extension to an existing configuration root, not a root of itself.  Moreover, our extension interface
                also carries a <code>@Group</code> annotation.  The annotation is necessary because the extension interface defines a group
                within the configuration hierarchy.  We need the annotation's <code>prefix</code> to determine under what namespace the
                extension interface's properties should be defined.  You'll read more about what <code>prefix</code> is and how it works in
                the next section.
            </para>
        </section>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Configuration Groups</title>

            <?dbfo-need height="10cm" ?>
            <para>
                So far, we've only defined the top-level groups.  Your top level group was either the root of the configuration hierarchy
                and extends <code>RootConfig</code>, or it was the root of your application extension and it extends <code>AppConfig</code>.
                Let's go a level deeper and look at what the <code>BrandingConfig</code> interface we referred to earlier could look like.
                Whether the group is referenced by a <code>RootConfig</code>, an <code>AppConfig</code> or another group doesn't matter.
                At this point, configuration groups all follow the same syntax. Here we can also see how to define configuration properties:
                <programlisting language="java" linenumbering="numbered"><![CDATA[
    @Group(prefix = "branding")
    public interface BrandingConfig {

        @Property(required = true, unset = "Your Company")
        String companyName();

        @Property(required = false)
        byte[] companyLogo();

        @Property(required = false)
        URL themeCSS();
    }
                ]]></programlisting>
            </para>
            <para>
                First, let's note a few important differences between this interface and the top-level group we defined before.  Since this
                interface does not define the root of the configuration hierarchy or an extension point, it does not extend
                <code>RootConfig</code> or <code>AppConfig</code>.  Also, since this group exists somewhere in the hierarchy, it needs a
                <code>@Group</code> annotation that specifies the group's prefix within the hierarchy.  The prefix tells the configuration
                framework what the namespace of the properties defined within this group will be called.  It should be a simple ASCII string
                that is also valid as a method name.  You'll notice that the prefix here is <code>branding</code>, the same name as the one
                we used for the method that returns this configuration interface.  It's required for the prefix of the group to match the
                name of the method that yields it.
            </para>
            <para>
                Also different from the earlier interface is the fact that we have non-group methods here.  Non-group methods define
                configuration properties and should always be annotated with <code>@Property</code>.  The <code>@Property</code> annotation
                serves to tell the configuration framework all the details about how to interpret this property.  The property can be
                required or optional.  Required properties will never yield <code>null</code> values (if a value cannot be found, the
                framework will throw an exception instead).  You can also provide an unset value, which is the value that will be returned
                when no other value can be found for this property.
            </para>
            <para>
                The method name is used to name the property whose value it returns.  When the internal name of this property is determined,
                the prefixes of all the groups accessed to reach this property from the root interface are all added together, separated by
                a dot, and the property name is added to the end.  This internal name is used to load a value for the property from
                different locations such as a property file, the servlet context, or a custom location.  In the case of the
                <code>companyName</code> property, the internal name would be: <code>branding.companyName</code>.
            </para>
        </section>
    </chapter>

    <chapter>
        <title>Accessing properties</title>

        <para>
            Once your configuration interfaces have been defined, all that remains is activating the configuration framework and making
            calls to the config property methods you defined earlier to access their values.
        </para>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Activating the configuration</title>

            <para>
                When your program accesses configuration properties, it does so via calls to static methods.  In the back-end, these static
                methods look up the active configuration implementation from a thread-local.  It is therefore vital that the configuration
                framework is first activated on the thread before any attempt of accessing it is made.
            </para>
            <para>
                If your application does not run within a servlet container and you want to create a single global config holder that is
                always active, you can activate a config holder globally with one of <code>ConfigHolder#setGlobalConfigHolderType</code> or
                <code>ConfigHolder#setGlobalConfigHolder</code>.  Globally activated config holders will be used when no local config holder
                has been activated.
            </para>
            <para>
                If your application works in a request-response type of manner, it's better to activate a config holder only for the
                duration of the request handling, on the current thread, and deactivate it when the request handling ends.  To do this,
                you'll need to call <code>ConfigHolder.setLocalConfigHolder</code> when the request handling begins and
                <code>ConfigHolder.unsetLocalConfigHolder</code> when it ends, preferably in a <code>finally</code> block.
            </para>
            <para>
                If your application runs within a servlet container, a convenience servlet filter exists, called <code>ConfigFilter</code>,
                which does the activation of a local config holder for you when a servlet request is initiated. The config is unbound
                from the thread when the request handling ends.
            </para>
            <para>
                There are two ways of using the <code>ConfigFilter</code>. Both involve adding the filter to the servlet context. Generally,
                applications configure their servlet context from <code>web.xml</code> in the <code>WEB-INF</code> directory of their web
                application archive.
            </para>
            <para>
                The first method requires you to create a custom implementation of <code>ConfigFilter</code>. You'll then activate that
                custom filter from <code>web.xml</code>. Your custom implementation can then pass all necessary information to the
                configuration framework.  The second method requires no Java code.  Instead, you'll be putting all the necessary information
                in <code>web.xml</code> as servlet context init parameters.
            </para>
            <?dbfo-need height="5cm" ?>
            <para>
                Either way, you'll need to put a config filter in <code>web.xml</code>.  Here's what the relevant part of
                <code>web.xml</code> might look like if you choose to reference a custom config filter:

                <programlisting language="xml" linenumbering="numbered"><![CDATA[
    <filter>
        <filter-name>ConfigFilter</filter-name>
        <filter-class>my.company.MyRootConfigFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>ConfigFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
                ]]></programlisting>
            </para>
            <para>
                Make sure the mapping comes early enough: The <code>ConfigFilter</code> must have been activated before any application code
                that might use it gets invoked.
            </para>
            <para>
                If you choose to use the standard <code>ConfigFilter</code> and specify the necessary information via servlet context init
                parameters, change the class name in the above example to <code>net.link.util.config.ConfigFilter</code>, and add the
                relevant servlet context init parameters to your servlet context.  The following table shows all available init parameters
                and explains their meaning:
            </para>
            <?dbfo-need height="5cm" ?>
            <variablelist>
                <title>Context parameters for the standard <code>ConfigFilter</code>:</title>
                <varlistentry>
                    <term>configHolder</term>
                    <listitem>
                        <para>
                            Use this parameter if you're creating a custom <code>ConfigHolder</code> implementation to bootstrap the config
                            framework.  The value is the class name of your custom <code>ConfigHolder</code> implementation.  Your custom
                            implementation must have a default constructor.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <?dbfo-need height="5cm" ?>
                    <term>configFactory</term>
                    <listitem>
                        <para>
                            Use this parameter if you're not creating a custom <code>ConfigHolder</code> implementation, but would like to
                            use the standard one.  This optional parameter can be used to specify a custom <code>DefaultConfigFactory</code>
                            implementation that should be used to wrap your config implementation or create default config implementations.
                            The value is the class name of your custom <code>DefaultConfigFactory</code> implementation.  Your custom
                            implementation must have a default constructor.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <?dbfo-need height="5cm" ?>
                    <term>configResource</term>
                    <listitem>
                        <para>
                            Use this parameter if you're not creating a custom <code>ConfigHolder</code> implementation and you're also not
                            creating a custom <code>DefaultConfigFactory</code> implementation.  This optional parameter can be used to
                            tell the standard <code>DefaultConfigFactory</code> where to read values for configuration properties from.
                            The value is a resource name that references a property file within the servlet context's classloader.
                        </para>
                        <para>
                            If this parameter is not set and you're using a standard <code>DefaultConfigFactory</code>, the property file
                            that will be read should be named <code>config.xml</code> or <code>config.properties</code>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <?dbfo-need height="5cm" ?>
                    <term>configClass</term>
                    <listitem>
                        <para>
                            Use this parameter if you're not creating a custom <code>ConfigHolder</code> implementation.  This parameter is
                            required, and is used to point the standard <code>ConfigHolder</code> implementation to your root config.
                            The root config class can be an interface such as we've seen in examples above, or it can be an implementation
                            of that interface.  If you refer to an implementation of that interface, the implementation will be instantiated
                            with its default constructor (and wrapped by the default config factory).  Your implementation will be used
                            whenever the root configuration is accessed. The value is the class name of your <code>RootConfig</code>
                            interface or an implementation of it.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                If you need access to the configuration framework from any servlet context listeners, those listeners will need to extend
                <code>ConfigContextListener</code> (or a custom implementation of it).  The same rules as for <code>ConfigFilter</code>
                apply.
            </para>
            <?dbfo-need height="10cm" ?>
            <para>
                For the sake of strong typing and extensibility, the first method (creating a custom <code>ConfigFilter</code>
                implementation) is highly recommended.  Creating a custom implementation of these classes is really easy.  Here's an example
                of a custom <code>ConfigFilter</code> implementation that references a custom <code>ConfigHolder</code> (you'll see why you
                may want a custom <code>ConfigHolder</code> in the next section):

                <programlisting language="java" linenumbering="numbered"><![CDATA[
    public class MyRootConfigFilter extends ConfigFilter {

        public MyRootConfigFilter() {

            super( new MyRootConfigHolder() );
        }
    }
                ]]></programlisting>
            </para>
        </section>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Accessing the configuration</title>

            <para>
                To access the values of your configuration properties, you will call the <code>config</code> method of the
                <code>ConfigHolder</code> class.  This method will give you an implementation of the interfaces you defined earlier.  From
                there on, it's easy to access any property by chaining your configuration method calls:
                <code>config().branding().companyName()</code>
            </para>
            <para>
                To make the <code>config</code> method return an object of the correct type (the type of your root configuration interface),
                rather than just <code>RootConfig</code>, there are two approaches:
            </para>
            <?dbfo-need height="5cm" ?>
            <variablelist>
                <title><code>config()</code> access methods:</title>
                <varlistentry>
                    <term><code>config( MyRootConfig.class ).configProperty()</code></term>
                    <listitem>
                        <para>You'll need a static import of <code>ConfigHolder.config</code>.</para>
                        <para>This syntax is rather verbose and thus a little inconvenient for general use.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><code>config().configProperty()</code></term>
                    <listitem>
                        <para>You'll need a static import of a custom subclass of <code>ConfigHolder</code>.</para>
                        <?dbfo-need height="5cm" ?>
                        <para>Your custom subclass provides a new <code>config()</code> method, which takes care of the typing:
                            <programlisting language="java" linenumbering="numbered"><![CDATA[
    public class MyRootConfigHolder extends ConfigHolder<MyRootConfig> {

        public MyRootConfigHolder() {

            super( new DefaultConfigFactory(), MyRootConfig.class, null );
        }

        public static MyRootConfig config() {

            return (MyRootConfig) ConfigHolder.config( MyRootConfig.class );
        }

        public static DefaultConfigFactory factory() {

            return (DefaultConfigFactory) ConfigHolder.factory( DefaultConfigFactory.class );
        }
    }
                            ]]></programlisting>
                        </para>
                        <para>Now you can statically import the <code>config()</code> method of this class and gain direct access to a
                            correctly-typed version of your config implementation.</para>
                        <para>Making your own <code>ConfigHolder</code> implementation also allows you to easily provide a custom
                            implementation or extension of the <code>DefaultConfigFactory</code>.  The use of this will be explained later
                            on.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                To access properties of an extension group, use the <code>app</code> method declared in <code>RootConfig</code>, passing
                the class of your extension interface as argument:
                <code>config().app( NotificationsModuleConfig.class ).email().fromAddress()</code>
            </para>
        </section>
    </chapter>

    <chapter>
        <title>Operation</title>

        <para>
            Even for just using the configuration framework, it pays to know how everything works internally.
        </para>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>The components</title>
            <para>
                Let's have a look at all of the separate components that make up the configuration framework, and what each component's
                job in the whole is:
            </para>
            <?dbfo-need height="5cm" ?>
            <variablelist>
                <varlistentry>
                    <term><code>RootConfig</code></term>
                    <listitem>
                        <para>
                            The interface that extends this interface marks the root of the configuration hierarchy.  Most other components
                            of the framework are only concerned with this root class.
                        </para>
                        <para>
                            To use the framework, you need a custom interface that extends this class, and you need to somehow activate
                            either a custom or a default implementation of this interface so that the properties can be accessed by calling
                            the methods defined in this interface and other group interfaces referenced by it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <?dbfo-need height="5cm" ?>
                    <term><code>AppConfig</code></term>
                    <listitem>
                        <para>
                            Interfaces that extend this interface can be used with the configuration framework's extension point.  The
                            extension point is: <code>config().app( [SomeAppConfig].class )</code>.
                        </para>
                        <para>
                            It's much the same as an ordinary config group, with the benefit that they are not referenced by and thus don't
                            need to be compiled along with your <code>RootConfig</code> interface. You can deploy a new web application with
                            a new <code>AppConfig</code> implementation at any time, and this new web application will be able to use the
                            config framework for its own configuration properties without the need for adding something to the root config.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <?dbfo-need height="5cm" ?>
                    <term><code>DefaultConfigFactory</code></term>
                    <listitem>
                        <para>
                            This class is used to create implementations for configuration interfaces.  It can create an instance for any
                            configuration interface.
                        </para>
                        <para>
                            Such an instance is called a default implementation of that interface (as opposed to a custom implementation of
                            the interface, which would be a class that you write, one which <code>implements</code> your configuration
                            interface).  Default implementations of configuration interfaces read configuration values from a property file
                            or the servlet context.
                        </para>
                        <para>
                            The standard <code>DefaultConfigFactory</code> will search for a property file called <code>config</code> (the
                            extension should be <code>.properties</code> if the file is a plain Java properties file or it should be
                            <code>.xml</code> if the file is an XML Java properties file.  The latter is highly recommended, since it is
                            structured, validatable and the text's encoding can be specified).  The search will happen with the context
                            classloader and the framework will look in the root of the classloader, in <code>../conf</code> and in
                            <code>../etc</code>.
                        </para>
                        <para>
                            This factory is also used to wrap invocations to a custom implementation of a configuration interface.  That
                            way, when you implement your configuration interface yourself but would like to return the value in the property
                            file, or the method's default value from its annotation, all you need to do is return <code>null</code> in your
                            method, and this factory, having wrapped the call to your custom implementation, will activate and search for
                            a good value to return instead of your <code>null</code>.
                        </para>
                        <para>
                            As a developer, you may want to extend this class to create your own custom <code>DefaultConfigFactory</code>.
                            Doing so will allow you to change the name of the property file that is searched for, and it will allow you to
                            add extra string-to-type conversion strategies.  You'll also be able to override the
                            <code>generateValueExtension</code> method, which will allow you to generate configuration values at runtime for
                            properties that are configured to auto-generate their value.  This method is a way of doing runtime value
                            generation for specific properties when no other value is set for that property. Only properties with an
                            <code>unset</code> value  set to <code>Property.AUTO</code> will trigger this method call when accessed and no
                            other value can be resolved for the property.
                        </para>
                        <para>
                            Finally, very commonly, applications may want to store the values of their configuration properties in a
                            different place.  Usually, applications that do this will store values in the database and provide a user
                            interface for operators to modify the configuration values.  To achieve this, the application developer should
                            override <code>getStringValueFor</code> and look up the value for a property from its database.  The application
                            can create the necessary database entries for the configuration properties in and referenced by the
                            application's <code>RootConfig</code> interface when the custom <code>DefaultConfigFactory</code> class is being
                            constructed.  However, this will not trigger creation of database entries for properties in application
                            extension interfaces.  To support this, the developer should hook the <code>getAppImplementation</code> call,
                            create database entries for the application extension interface, and delegate back to <code>super</code>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <?dbfo-need height="5cm" ?>
                    <term><code>ConfigHolder</code></term>
                    <listitem>
                        <para>
                            The config holder is used to hold the active configuration implementations in memory.  It also provides your
                            application access to them.
                        </para>
                        <para>
                            Local holders are always activated on the current thread.  When the operation that activated the holder
                            completes, the holder is deactivated again, and detached from the current thread.  Global holders are always
                            active on all threads, from the moment they've been installed.  When a local and a global holder are active at
                            the same time, the local holder is used. As long as the holder is active, it can provide the application access
                            to the implementations contained within.
                        </para>
                        <para>
                            This class is normally extended by the application that provides the <code>RootConfig</code>, so that it can
                            provide cleaner access to a well-typed version of the <code>config</code> method.  The application normally
                            provides its own <code>config()</code> method that has its own extension of the <code>RootConfig</code> as
                            return value, and delegates to <code>ConfigHolder.config( MyRootConfig.class )</code>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <?dbfo-need height="5cm" ?>
                    <term><code>ConfigFilter</code> and <code>ConfigContextListener</code></term>
                    <listitem>
                        <para>
                            These classes are used to activate a <code>ConfigHolder</code> when the application runs within a a servlet
                            container.
                        </para>
                        <para>
                            Whenever a servlet call triggers the application, the filter (which should come first in the list of filter
                            mappings) determines which holder to activate (either you have a custom implementation of this filter, or the
                            filter looks through the servlet context's init parameters to determine how to operate).  When the filtered call
                            completes (whether it was successfully handled or resulted in failure or an exception is irrelevant), the holder
                            that was previously activated is deactivated again.
                        </para>
                        <para>
                            The context listener works in much the same way as the filter, but triggers when the application is being
                            initialized or destroyed, and only for the duration of its very own <code>doContextInitialized</code> and
                            <code>doContextDestroyed</code> calls.  It is therefore vital that any context listeners that need access to the
                            configuration framework extend this abstract class.
                        </para>
                        <para>
                            This class is normally extended by the application that provides the <code>RootConfig</code>, so that it can
                            provide cleaner access to a well-typed version of the <code>config</code> method.  The application normally
                            provides its own <code>config()</code> method that has its own extension of the <code>RootConfig</code> as
                            return value, and delegates to <code>ConfigHolder.config( MyRootConfig.class )</code>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Loading property values</title>

            <para>
                The implementation of your configuration interface can either be a class created by you or a default implementation created
                by <code>DefaultConfigFactory</code>.
            </para>
            <para>
                In the first case, when a property method is invoked by the application, your class' code for that method is invoked.  Your
                class' method can return a value for the property, or it can return <code>null</code> in which case
                <code>DefaultConfigFactory</code>'s wrapper will intervene and a value will be searched for the property in the same manner
                as if you did not have a custom implementation of the configuration interface.
            </para>
            <para>
                The <code>DefaultConfigFactory</code> always uses a property's internal name to search for a value of the property. The
                internal name of a property is a composition of the method names used to navigate the configuration hierarchy from the root
                to the property, each element delimited from the next with a period.  As such, a property that you'd access in code by using
                <code>config().authentication().identity().name()</code> will be loaded with an internal name
                <code>authentication.identity.name</code>.
            </para>
            <para>
                The <code>DefaultConfigFactory</code> loads a value from one of three locations. The search locations have a well-defined
                order. If no value is given for a property in one location, the next location is tried.

                <?dbfo-need height="5cm" ?>
                <variablelist>
                    <title>Property locations in search order</title>
                    <varlistentry>
                        <term>Servlet Context</term>
                        <listitem>
                            <para>
                                If a servlet context is active (eg. you're using the <code>ConfigFilter</code>), its init parameters will be
                                searched for a parameter named by the property's internal name. These init parameters are generally provided
                                by use of <code>context-param</code> elements in the application's <code>web.xml</code>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Property File</term>
                        <listitem>
                            <para>
                                The classpath is searched for a property file named <code>config.xml</code> (for XML-encoded properties)
                                or <code>config.properties</code> (for plain properties).  If an XML property file is found, it is used and
                                the framework doesn't continue looking for a plain property file. Since XML-encoded property files are
                                validatable and specify their own text encoding, they are highly recommended over plain property files.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Unset Value</term>
                        <listitem>
                            <para>
                                When a property had no value defined in any other location, the framework will look at the property's
                                annotation to search for a value to return.  The <code>unset</code> parameter of the annotation is used
                                if set (to something other than <code>Property.NONE</code>).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                If the configuration framework fails to resolve a value for a property call through any means, the result depends on whether
                the property is required.  Required properties are those that have the <code>required</code> parameter of their annotation
                set to <code>true</code>.  If the property is required and no value for the property can be found, the framework will throw
                a runtime exception.  If the property is optional, the property method call will yield <code>null</code>.
            </para>
            <?dbfo-need height="5cm" ?>
            <para>Here's an example of what an XML property file might look like:
                <programlisting language="xml" linenumbering="numbered"><![CDATA[
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
    <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">

    <properties>

        <entry key="branding.companyName">My Company</entry>
        <entry key="branding.companyLogo">
            aG93ZHktaG8tSS1hbS1hLWZha2UtY29tcGFueS1sb2dvLXN0cmluZwo=
        </entry>
        <entry key="branding.themeCSS">bliss.css</entry>

        <entry key="authentication.identity.name">mycompany</entry>
        <entry key="authentication.identity.keyProvider">
            classpath://myapp:mycompany-pass:myapp-pass@mycompany.jks
        </entry>

    </properties>
                ]]></programlisting>
            </para>
            <para>
                As you can see, the contents of the <code>properties</code> tag is a sequence of <code>entry</code> tags which specify a
                <code>key</code> attribute and provide a string value as content.  The value of the <code>key</code> attribute specifies the
                internal name of the property for which the value is given.
            </para>
            <?dbfo-need height="10cm" ?>
            <para>
                Configuration values can also be defined in the servlet context.  For example, an application developer might use the
                following <code>web.xml</code> to deploy his application:

                <programlisting language="xml" linenumbering="numbered"><![CDATA[
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
            "http://java.sun.com/dtd/web-app_2_3.dtd">

    <web-app>

        <display-name>My Application</display-name>

        <!-- SDK Configuration -->
        <context-param>
            <param-name>branding.companyName</param-name>
            <param-value>My Company</param-value>
        </context-param>
        <context-param>
            <param-name>branding.companyLogo</param-name>
            <param-value>aG93ZHktaG8tSS1hbS1hLWZha2UtY29tcGFueS1sb2dvLXN0cmluZwo=</param-value>
        </context-param>
        <context-param>
            <param-name>branding.themeCSS</param-name>
            <param-value>bliss.css</param-value>
        </context-param>

        <context-param>
            <param-name>authentication.identity.name</param-name>
            <param-value>mycompany</param-value>
        </context-param>
        <context-param>
            <param-name>authentication.identity.keyProvider</param-name>
            <param-value>classpath://myapp:mycompany-pass:myapp-pass@mycompany.jks</param-value>
        </context-param>

        <!-- SDK Configuration Filter -->
        <filter>
            <filter-name>ConfigFilter</filter-name>
            <filter-class>my.company.MyRootConfigFilter</filter-class>
        </filter>

        <!-- Application's Web Framework -->
        <filter>
            <filter-name>WicketFilter</filter-name>
            <filter-class>org.apache.wicket.protocol.http.WicketFilter</filter-class>

            <init-param>
                <param-name>applicationClassName</param-name>
                <param-value>my.company.myapp.webapp.MyApplication</param-value>
            </init-param>
        </filter>

        <!-- Map filters to URLs -->
        <filter-mapping>
            <filter-name>ConfigFilter</filter-name>
            <url-pattern>/*</url-pattern>
        </filter-mapping>
        <filter-mapping>
            <filter-name>WicketFilter</filter-name>
            <url-pattern>/*</url-pattern>
        </filter-mapping>

        <!-- Initialization -->
        <listener>
            <listener-class>my.company.myapp.webapp.listener.MyApplicationContextListener</listener-class>
        </listener>

    </web-app>
                ]]></programlisting>
            </para>
            <para>
                In this case, property values are defined within <code>context-param</code> tags.  The <code>param-name</code> child
                specifies the internal name of the property while the <code>param-value</code> specifies the property's value.
            </para>
            <para>
                It's important to note the main advantage of not putting the property values in your <code>web.xml</code>: If they are
                defined in a property file that's in your classpath, you can put the file somewhere in your servlet container's
                configuration or lib directory, making it easily accessible while the server is running.  That means it's easy to update
                these values without the need for rebuilding or repackaging the application.  With this in mind, also note that it's
                possible to divide parameters between both sources.  You may choose to define most parameters in a property file and leave
                the static ones or those that are specific to the scope of one of your web applications defined in your application's
                <code>web.xml</code>. Note that values in the servlet's context override any values specified by your property file.  This
                allows you to scope certain properties to a servlet context while leaving a more generic default for those servlet contexts
                that don't specify their own scoped value.
            </para>
        </section>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Value filtering</title>

            <para>
                After a value for a property has been loaded by the <code>DefaultConfigFactory</code>, the string value first undergoes
                filtering.  Filtering is a process that is applied to a loaded value to modify or interpret it in a runtime-specific manner.
                The standard <code>DefaultConfigFactory</code> performs two filtering operations, in the following order:
                <?dbfo-need height="5cm" ?>
                <variablelist>
                    <title>Standard filtering operations</title>
                    <varlistentry>
                        <term>System property expansion</term>
                        <listitem>
                            <para>
                                The string value is scanned for words of the syntax: <code>${[system-property]}</code>.  The name of the
                                system property cannot contain back-brace (<code>}</code>) characters.  If such a word is found in the
                                value, it is removed and replaced by the value of the system property that is referenced.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Resource loading</term>
                        <listitem>
                            <para>
                                If the string value begins with the five characters: <code>load:</code>, then the string after this keyword
                                is taken as a resource name and the current thread's context classloader is searched for a resource by that
                                name.  If such a resource is found, the resource's bytes are read in and converted to a character string
                                using <code>UTF-8</code> as encoding.  The resulting characters are then used instead of the original value.
                                If the resource cannot be found, a <code>null</code> value results.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                You can add your own filter operations by using a custom implementation of the <code>DefaultConfigFactory</code> class and
                overriding the <code>filter</code> method.  Make sure to invoke the <code>super</code> implementation of the method before
                performing your own filter operations on the result of it.
            </para>
            <para>
                Note that filtering is only performed on string values and in no way affects objects returned by your custom config
                implementations.
            </para>
        </section>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Type conversion</title>

            <para>
                Internally, property values are always stored as character data or <code>String</code> objects.  The configuration framework
                has strategies in place to convert these values (after filtering as described in the previous chapter) into fully typed
                objects.  By looking at property your method declaration's return value, it determines what strategy to use to convert the
                value into the type that you desire. By default it supports the following conversions:
                <?dbfo-need height="5cm" ?>
                <variablelist>
                    <title>Conversion strategies</title>
                    <varlistentry>
                        <term><code>String</code> or <code>Object</code> typed properties or <code>null</code> property values</term>
                        <listitem>
                            <para>
                                No conversion is performed, the value is returned as a <code>String</code> object, or as <code>null</code>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Byte Arrays</term>
                        <listitem>
                            <para>
                                Properties typed to accept <code>byte</code> or <code>Byte</code> arrays will make the framework decode
                                the property value's characters with the Base 64 algorithm into a stream of bytes.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Joda-Time</term>
                        <listitem>
                            <para>
                                Properties typed to accept <code>DateTime</code> objects will make the framework parse the property value as a date
                                (with optional time) string (in UTC) using the standard ISO format.
                            </para>
                            <para>
                                Properties typed to accept <code>Duration</code> objects will make the framework parse the property value as a long
                                integer and use this number as an amount of milliseconds until the duration has elapsed.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Key Stores</term>
                        <listitem>
                            <para>
                                To make handling keys and certificates easy, the framework supports key stores.  Set your property's
                                return type to <code>KeyStore</code> and the property value will be converted to a <code>KeyStore</code>
                                instance that provides access to the keys and certificates within.
                            </para>
                            <para>
                                The syntax of the string value for this property is: <code>resource[:password[:format]]</code>.  The value
                                begins with a named <code>resource</code>.  The resource name should not contain any colon (<code>:</code>)
                                characters.  It is the name of a keystore resource that will be loaded by the thread's context classloader.
                                The second value is a password.  The password should also not contain any colon characters.  If the password
                                is omitted, the framework attempts to load the keystore without unlocking it. The password will be used to
                                unlock the key store once it is loaded by the classloader from the named resource.  Finally, the keystore's
                                type can be passed.  This type identifies the format that is used by the keystore resource to encode its key
                                information.  By default, Java supports <code>JKS</code> and <code>PKCS12</code> key stores. The type
                                defaults to <code>JKS</code>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Key Providers</term>
                        <listitem>
                            <para>
                                Key providers are a handy API for accessing identity and trust information.  The key and certificates are
                                obtained from implementation-specific locations (most implementations load the information from a key store).
                            </para>
                            <para>
                                The syntax for key provider property values is explained in detail by the next section.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Enumerations</term>
                        <listitem>
                            <para>
                                Properties typed with an <code>enum</code> type will make the framework search the given enumeration type for a
                                constant with the same name as your property's value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Reflection</term>
                        <listitem>
                            <para>
                                To support a wide range of custom types, failing the above strategies, the framework will check your property's
                                type for a constructor that takes a single <code>String</code> parameter.  If such a constructor is found, it is used
                                to construct a typed object by passing in the property's value.
                            </para>
                            <para>This strategy is an excellent fallback and immediately provides support for a great many standard Java types such as
                                numbers, URLs, etc.
                            </para>
                            <para>It also makes it really easy for you to use custom objects with the configuration framework.  All you need to do is
                                provide a <code>toString()</code> implementation that encodes your custom object's data as a property value and a
                                <code>String</code> constructor that parses a property value back into a new fully restored custom object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Collections</term>
                        <listitem>
                            <para>
                                Properties with a type that's a collection will cause the framework to split the property value into chunks.  Your
                                collection type (or a concrete subtype of it) is instantiated and the chunks are added to it.
                            </para>
                            <para>
                                Property values are split using commas as delimitors.  Leading and trailing whitespace is stripped from each chunk.
                                For example, the following property value: <code>apple, pear, banana</code> will yield a collection of three elements.
                            </para>
                            <para>
                                For the moment, only collections of <code>String</code>s are supported.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                By extending <code>DefaultConfigFactory</code> with your custom implementation, you can add support for additional
                conversion strategies.  To do so, override the <code>toTypeExtension</code> method.
            </para>
        </section>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Key providers</title>
            <para>
                Key providers are objects that obtain keys and certificates from a certain location and make them available to your
                application. The framework supports a number of different key provider implementations.  Each implementation obtains the
                keys and certificates from a specific source.  Thanks to key providers, accessing identity and trust information is
                decoupled from where the information is stored and how it is loaded.  This allows operators to keep the information in the
                most convenient location, and to easily update it or move it to a different location.
            </para>
            <para>
                The syntax of a key provider property value is: <code>type://[alias[:key-store-pass[:key-entry-pass]]@]path</code>.
                Note that you cannot use <code>:</code> or <code>@</code> symbols in passwords or aliases. The optional alias is used to
                load the identity entry from the key store.  The optional key store password is used to unlock the key store.  The optional
                key entry password is used to unlock the key entry referenced by the identity alias.  If the alias is omitted, it defaults
                to <code>identity</code>.  If the key entry is not sealed you can omit the key entry password.  If the key store is also not
                sealed, you can omit the key store password as well.  Note that in this event, you should have other protections in place to
                guarantee the security of your identity keys and trusted certificates. The following key provider implementations are
                provided by the configuration framework:
                <?dbfo-need height="5cm" ?>
                <variablelist>
                    <title>Key provider implementations</title>
                    <varlistentry>
                        <term>Classpath (<code>classpath://...</code>)</term>
                        <listitem>
                            <para>
                                The current thread's context classloader is used to look up the resource named by the <code>path</code>.
                                The resource is loaded as a <code>JKS</code> <code>KeyStore</code>.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>Remote (<code>url://...</code>)</term>
                        <listitem>
                            <para>
                                A stream is opened to the URL given in <code>path</code> and the response is loaded in as a <code>JKS</code>
                                <code>KeyStore</code>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>File (<code>file://...</code>)</term>
                        <listitem>
                            <para>
                                The file at the given <code>path</code> is opened, read in and loaded as a <code>JKS</code>
                                <code>KeyStore</code>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <?dbfo-need height="5cm" ?>
                        <term>A KeyProvider class (<code>class://...</code>)</term>
                        <listitem>
                            <para>
                                The current thread's context classloader is used to load the class named by the given <code>path</code>.
                                This should be the fully-qualified name of the class within the classloader.
                            </para>
                            <para>
                                Your class must extend your property method's return type. The class will be instantiated by searching for
                                the first supported constructor that exists.  The framework will first search for a constructor that takes
                                three <code>String</code>s, and pass in the <code>key-store-pass</code>, <code>key-entry-alias</code> and
                                <code>key-entry-pass</code> as parameters.  If such a constructor does not exist, it will look for a
                                constructor that takes two <code>String</code>s, and pass in the <code>key-entry-alias</code> and
                                <code>key-entry-pass</code> as parameters.  Failing that, it will search for a constructor that takes one
                                <code>String</code> and pass in the <code>key-entry-alias</code>.  In a last attempt, it will try to
                                construct the object with the default constructor.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </section>

        <section>
            <?dbfo-need height="10cm" ?>
            <title>Custom Config Implementation</title>
            <para>
                The configuration framework was written with maximum customizability and freedom to application developers in mind. There
                are situation where the default implementation is inadequate: You may prefer to provide your configuration values in a more
                type-safe way, your application may require you to dynamically provide different configuration values for certain properties
                depending on some external state or your application may not be running inside a servlet container at all.
            </para>
            <para>
                To provide your own implementation of the SDK config, all you need to do is implement the <code>RootConfig</code> interface
                and the interfaces it references.  Any property values you wish to have resolved in the default manner, you can return
                <code>null</code> for in your implementation.  Similarly, any groups you wish to create a default implementation for, you
                can return <code>null</code> for.
            </para>
            <para>
                To activate your custom implementation instead of a default implementation, pass the custom implementation to the
                <code>ConfigHolder</code> you're creating.  To pass your implementation to a default <code>ConfigHolder</code> from a custom
                <code>ConfigFilter</code>, instantiate your implementation and pass it as an argument when you create the
                <code>ConfigHolder</code> for your custom <code>ConfigFilter</code>.  To pass your implementation to a default
                <code>ConfigHolder</code> from a default <code>ConfigFilter</code> by means of a servlet context init parameter, set the
                init parameter <code>configClass</code> to the class name of your custom config implementation, and make sure it has a
                default constructor that can be used to instantiate the class.
            </para>
        </section>
    </chapter>

</book>
